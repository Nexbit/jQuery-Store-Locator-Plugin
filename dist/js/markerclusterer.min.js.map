{"version":3,"sources":["markerclusterer.js"],"names":["MarkerClusterer","map","opt_markers","opt_options","this","extend","google","maps","OverlayView","map_","markers_","clusters_","sizes","styles_","ready_","options","gridSize_","minClusterSize_","maxZoom_","imagePath_","MARKER_CLUSTER_IMAGE_PATH_","imageExtension_","MARKER_CLUSTER_IMAGE_EXTENSION_","zoomOnClick_","undefined","averageCenter_","setupStyles_","setMap","prevZoom_","getZoom","that","event","addListener","zoom","resetViewport","redraw","length","addMarkers","Cluster","markerClusterer","markerClusterer_","getMap","getGridSize","getMinClusterSize","isAverageCenter","center_","bounds_","clusterIcon_","ClusterIcon","getStyles","cluster","styles","opt_padding","getMarkerClusterer","padding_","cluster_","div_","sums_","visible_","prototype","obj1","obj2","object","property","apply","onAdd","setReady_","draw","size","i","push","url","height","width","fitMapToMarkers","marker","markers","getMarkers","bounds","LatLngBounds","getPosition","fitBounds","setStyles","isZoomOnClick","getTotalMarkers","setMaxZoom","maxZoom","getMaxZoom","calculator_","numStyles","index","count","dv","parseInt","text","Math","min","setCalculator","calculator","getCalculator","opt_nodraw","pushMarkerTo_","isAdded","repaint","addMarker","removeMarker_","indexOf","m","splice","removeMarker","removed","removeMarkers","r","ready","createClusters_","getTotalClusters","setGridSize","setMinClusterSize","getExtendedBounds","projection","getProjection","tr","LatLng","getNorthEast","lat","lng","bl","getSouthWest","trPix","fromLatLngToDivPixel","x","y","blPix","ne","fromDivPixelToLatLng","sw","isMarkerInBounds_","contains","clearMarkers","opt_hide","remove","oldClusters","slice","window","setTimeout","distanceBetweenPoints_","p1","p2","dLat","PI","dLon","a","sin","cos","atan2","sqrt","addToClosestCluster_","distance","clusterToAddTo","center","getCenter","d","isMarkerInClusterBounds","mapBounds","getBounds","isMarkerAlreadyAdded","l","calculateBounds_","len","updateIcon","getSize","mz","hide","sums","setCenter","setSums","show","triggerClusterClick","trigger","document","createElement","pos","getPosFromLatLng_","style","cssText","createCss","innerHTML","getPanes","overlayMouseTarget","appendChild","isDragging","addDomListener","latlng","iconAnchor_","width_","height_","top","left","display","onRemove","parentNode","removeChild","text_","index_","useStyle","max","url_","textColor_","anchor_","textSize_","backgroundPosition_","backgroundPosition","txtColor","txtSize","join"],"mappings":"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","sourceRoot":"source-maps","sourcesContent":["// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @externs_url https://raw.githubusercontent.com/google/closure-compiler/master/contrib/externs/maps/google_maps_api_v3.js\n// ==/ClosureCompiler==\n\n/**\n * @name MarkerClusterer for Google Maps v3\n * @version version 1.0\n * @author Luke Mahe\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of\n * markers.\n * <br/>\n * This is a v3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >v2 MarkerClusterer</a>.\n *\n * @license\n * Copyright 2010 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A Marker Clusterer that clusters markers.\n *\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to\n *   the cluster.\n * @param {Object=} opt_options support the following options:\n *     'gridSize': (number) The grid size of a cluster in pixels.\n *     'maxZoom': (number) The maximum zoom level that a marker can be part of a\n *                cluster.\n *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a\n *                    cluster is to zoom into it.\n *     'averageCenter': (boolean) Whether the center of each cluster should be\n *                      the average of all markers in the cluster.\n *     'minimumClusterSize': (number) The minimum number of markers to be in a\n *                           cluster before the markers are hidden and a count\n *                           is shown.\n *     'styles': (object) An object that has style properties:\n *       'url': (string) The image url.\n *       'height': (number) The image height.\n *       'width': (number) The image width.\n *       'anchor': (Array) The anchor position of the label text.\n *       'textColor': (string) The text color.\n *       'textSize': (number) The text size.\n *       'backgroundPosition': (string) The position of the backgound x, y.\n *       'iconAnchor': (Array) The anchor position of the icon x, y.\n * @constructor\n * @extends google.maps.OverlayView\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n\t// MarkerClusterer implements google.maps.OverlayView interface. We use the\n\t// extend function to extend MarkerClusterer with google.maps.OverlayView\n\t// because it might not always be available when the code is defined so we\n\t// look for it at the last possible moment. If it doesn't exist now then\n\t// there is no point going ahead :)\n\tthis.extend(MarkerClusterer, google.maps.OverlayView);\n\tthis.map_ = map;\n\n\t/**\n\t * @type {Array.<google.maps.Marker>}\n\t * @private\n\t */\n\tthis.markers_ = [];\n\n\t/**\n\t *  @type {Array.<Cluster>}\n\t */\n\tthis.clusters_ = [];\n\n\tthis.sizes = [53, 56, 66, 78, 90];\n\n\t/**\n\t * @private\n\t */\n\tthis.styles_ = [];\n\n\t/**\n\t * @type {boolean}\n\t * @private\n\t */\n\tthis.ready_ = false;\n\n\tvar options = opt_options || {};\n\n\t/**\n\t * @type {number}\n\t * @private\n\t */\n\tthis.gridSize_ = options['gridSize'] || 60;\n\n\t/**\n\t * @private\n\t */\n\tthis.minClusterSize_ = options['minimumClusterSize'] || 2;\n\n\n\t/**\n\t * @type {?number}\n\t * @private\n\t */\n\tthis.maxZoom_ = options['maxZoom'] || null;\n\n\tthis.styles_ = options['styles'] || [];\n\n\t/**\n\t * @type {string}\n\t * @private\n\t */\n\tthis.imagePath_ = options['imagePath'] ||\n\t\tthis.MARKER_CLUSTER_IMAGE_PATH_;\n\n\t/**\n\t * @type {string}\n\t * @private\n\t */\n\tthis.imageExtension_ = options['imageExtension'] ||\n\t\tthis.MARKER_CLUSTER_IMAGE_EXTENSION_;\n\n\t/**\n\t * @type {boolean}\n\t * @private\n\t */\n\tthis.zoomOnClick_ = true;\n\n\tif (options['zoomOnClick'] != undefined) {\n\t\tthis.zoomOnClick_ = options['zoomOnClick'];\n\t}\n\n\t/**\n\t * @type {boolean}\n\t * @private\n\t */\n\tthis.averageCenter_ = false;\n\n\tif (options['averageCenter'] != undefined) {\n\t\tthis.averageCenter_ = options['averageCenter'];\n\t}\n\n\tthis.setupStyles_();\n\n\tthis.setMap(map);\n\n\t/**\n\t * @type {number}\n\t * @private\n\t */\n\tthis.prevZoom_ = this.map_.getZoom();\n\n\t// Add the map event listeners\n\tvar that = this;\n\tgoogle.maps.event.addListener(this.map_, 'zoom_changed', function() {\n\t\tvar zoom = that.map_.getZoom();\n\n\t\tif (that.prevZoom_ != zoom) {\n\t\t\tthat.prevZoom_ = zoom;\n\t\t\tthat.resetViewport();\n\t\t}\n\t});\n\n\tgoogle.maps.event.addListener(this.map_, 'idle', function() {\n\t\tthat.redraw();\n\t});\n\n\t// Finally, add the markers\n\tif (opt_markers && opt_markers.length) {\n\t\tthis.addMarkers(opt_markers, false);\n\t}\n}\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';\n\n\n/**\n * The marker cluster image path.\n *\n * @type {string}\n * @private\n */\nMarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';\n\n\n/**\n * Extends a objects prototype by anothers.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function(obj1, obj2) {\n\treturn (function(object) {\n\t\tfor (var property in object.prototype) {\n\t\t\tthis.prototype[property] = object.prototype[property];\n\t\t}\n\t\treturn this;\n\t}).apply(obj1, [obj2]);\n};\n\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function() {\n\tthis.setReady_(true);\n};\n\n/**\n * Implementaion of the interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function() {};\n\n/**\n * Sets up the styles object.\n *\n * @private\n */\nMarkerClusterer.prototype.setupStyles_ = function() {\n\tif (this.styles_.length) {\n\t\treturn;\n\t}\n\n\tfor (var i = 0, size; size = this.sizes[i]; i++) {\n\t\tthis.styles_.push({\n\t\t\turl: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,\n\t\t\theight: size,\n\t\t\twidth: size\n\t\t});\n\t}\n};\n\n/**\n *  Fit the map to the bounds of the markers in the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function() {\n\tvar markers = this.getMarkers();\n\tvar bounds = new google.maps.LatLngBounds();\n\tfor (var i = 0, marker; marker = markers[i]; i++) {\n\t\tbounds.extend(marker.getPosition());\n\t}\n\n\tthis.map_.fitBounds(bounds);\n};\n\n\n/**\n *  Sets the styles.\n *\n *  @param {Object} styles The style to set.\n */\nMarkerClusterer.prototype.setStyles = function(styles) {\n\tthis.styles_ = styles;\n};\n\n\n/**\n *  Gets the styles.\n *\n *  @return {Object} The styles object.\n */\nMarkerClusterer.prototype.getStyles = function() {\n\treturn this.styles_;\n};\n\n\n/**\n * Whether zoom on click is set.\n *\n * @return {boolean} True if zoomOnClick_ is set.\n */\nMarkerClusterer.prototype.isZoomOnClick = function() {\n\treturn this.zoomOnClick_;\n};\n\n/**\n * Whether average center is set.\n *\n * @return {boolean} True if averageCenter_ is set.\n */\nMarkerClusterer.prototype.isAverageCenter = function() {\n\treturn this.averageCenter_;\n};\n\n\n/**\n *  Returns the array of markers in the clusterer.\n *\n *  @return {Array.<google.maps.Marker>} The markers.\n */\nMarkerClusterer.prototype.getMarkers = function() {\n\treturn this.markers_;\n};\n\n\n/**\n *  Returns the number of markers in the clusterer\n *\n *  @return {Number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function() {\n\treturn this.markers_.length;\n};\n\n\n/**\n *  Sets the max zoom for the clusterer.\n *\n *  @param {number} maxZoom The max zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function(maxZoom) {\n\tthis.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Gets the max zoom for the clusterer.\n *\n *  @return {number} The max zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function() {\n\treturn this.maxZoom_;\n};\n\n\n/**\n *  The function for calculating the cluster icon image.\n *\n *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.\n *  @param {number} numStyles The number of styles available.\n *  @return {Object} A object properties: 'text' (string) and 'index' (number).\n *  @private\n */\nMarkerClusterer.prototype.calculator_ = function(markers, numStyles) {\n\tvar index = 0;\n\tvar count = markers.length;\n\tvar dv = count;\n\twhile (dv !== 0) {\n\t\tdv = parseInt(dv / 10, 10);\n\t\tindex++;\n\t}\n\n\tindex = Math.min(index, numStyles);\n\treturn {\n\t\ttext: count,\n\t\tindex: index\n\t};\n};\n\n\n/**\n * Set the calculator function.\n *\n * @param {function(Array, number)} calculator The function to set as the\n *     calculator. The function should return a object properties:\n *     'text' (string) and 'index' (number).\n *\n */\nMarkerClusterer.prototype.setCalculator = function(calculator) {\n\tthis.calculator_ = calculator;\n};\n\n\n/**\n * Get the calculator function.\n *\n * @return {function(Array, number)} the calculator function.\n */\nMarkerClusterer.prototype.getCalculator = function() {\n\treturn this.calculator_;\n};\n\n\n/**\n * Add an array of markers to the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {\n\tfor (var i = 0, marker; marker = markers[i]; i++) {\n\t\tthis.pushMarkerTo_(marker);\n\t}\n\tif (!opt_nodraw) {\n\t\tthis.redraw();\n\t}\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function(marker) {\n\tmarker.isAdded = false;\n\tif (marker['draggable']) {\n\t\t// If the marker is draggable add a listener so we update the clusters on\n\t\t// the drag end.\n\t\tvar that = this;\n\t\tgoogle.maps.event.addListener(marker, 'dragend', function() {\n\t\t\tmarker.isAdded = false;\n\t\t\tthat.repaint();\n\t\t});\n\t}\n\tthis.markers_.push(marker);\n};\n\n\n/**\n * Adds a marker to the clusterer and redraws if needed.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean=} opt_nodraw Whether to redraw the clusters.\n */\nMarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {\n\tthis.pushMarkerTo_(marker);\n\tif (!opt_nodraw) {\n\t\tthis.redraw();\n\t}\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n * @private\n */\nMarkerClusterer.prototype.removeMarker_ = function(marker) {\n\tvar index = -1;\n\tif (this.markers_.indexOf) {\n\t\tindex = this.markers_.indexOf(marker);\n\t} else {\n\t\tfor (var i = 0, m; m = this.markers_[i]; i++) {\n\t\t\tif (m == marker) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (index == -1) {\n\t\t// Marker is not in our list of markers.\n\t\treturn false;\n\t}\n\n\tmarker.setMap(null);\n\n\tthis.markers_.splice(index, 1);\n\n\treturn true;\n};\n\n\n/**\n * Remove a marker from the cluster.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n * @return {boolean} True if the marker was removed.\n */\nMarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {\n\tvar removed = this.removeMarker_(marker);\n\n\tif (!opt_nodraw && removed) {\n\t\tthis.resetViewport();\n\t\tthis.redraw();\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n};\n\n\n/**\n * Removes an array of markers from the cluster.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean=} opt_nodraw Optional boolean to force no redraw.\n */\nMarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {\n\tvar removed = false;\n\n\tfor (var i = 0, marker; marker = markers[i]; i++) {\n\t\tvar r = this.removeMarker_(marker);\n\t\tremoved = removed || r;\n\t}\n\n\tif (!opt_nodraw && removed) {\n\t\tthis.resetViewport();\n\t\tthis.redraw();\n\t\treturn true;\n\t}\n};\n\n\n/**\n * Sets the clusterer's ready state.\n *\n * @param {boolean} ready The state.\n * @private\n */\nMarkerClusterer.prototype.setReady_ = function(ready) {\n\tif (!this.ready_) {\n\t\tthis.ready_ = ready;\n\t\tthis.createClusters_();\n\t}\n};\n\n\n/**\n * Returns the number of clusters in the clusterer.\n *\n * @return {number} The number of clusters.\n */\nMarkerClusterer.prototype.getTotalClusters = function() {\n\treturn this.clusters_.length;\n};\n\n\n/**\n * Returns the google map that the clusterer is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nMarkerClusterer.prototype.getMap = function() {\n\treturn this.map_;\n};\n\n\n/**\n * Sets the google map that the clusterer is associated with.\n *\n * @param {google.maps.Map} map The map.\n */\nMarkerClusterer.prototype.setMap = function(map) {\n\tthis.map_ = map;\n};\n\n\n/**\n * Returns the size of the grid.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function() {\n\treturn this.gridSize_;\n};\n\n\n/**\n * Sets the size of the grid.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function(size) {\n\tthis.gridSize_ = size;\n};\n\n\n/**\n * Returns the min cluster size.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getMinClusterSize = function() {\n\treturn this.minClusterSize_;\n};\n\n/**\n * Sets the min cluster size.\n *\n * @param {number} size The grid size.\n */\nMarkerClusterer.prototype.setMinClusterSize = function(size) {\n\tthis.minClusterSize_ = size;\n};\n\n\n/**\n * Extends a bounds object by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n */\nMarkerClusterer.prototype.getExtendedBounds = function(bounds) {\n\tvar projection = this.getProjection();\n\n\t// Turn the bounds into latlng.\n\tvar tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n\t\tbounds.getNorthEast().lng());\n\tvar bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n\t\tbounds.getSouthWest().lng());\n\n\t// Convert the points to pixels and the extend out by the grid size.\n\tvar trPix = projection.fromLatLngToDivPixel(tr);\n\ttrPix.x += this.gridSize_;\n\ttrPix.y -= this.gridSize_;\n\n\tvar blPix = projection.fromLatLngToDivPixel(bl);\n\tblPix.x -= this.gridSize_;\n\tblPix.y += this.gridSize_;\n\n\t// Convert the pixel points back to LatLng\n\tvar ne = projection.fromDivPixelToLatLng(trPix);\n\tvar sw = projection.fromDivPixelToLatLng(blPix);\n\n\t// Extend the bounds to contain the new bounds.\n\tbounds.extend(ne);\n\tbounds.extend(sw);\n\n\treturn bounds;\n};\n\n\n/**\n * Determins if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n * @private\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {\n\treturn bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Clears all clusters and markers from the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function() {\n\tthis.resetViewport(true);\n\n\t// Set the markers a empty array.\n\tthis.markers_ = [];\n};\n\n\n/**\n * Clears all existing clusters and recreates them.\n * @param {boolean} opt_hide To also hide the marker.\n */\nMarkerClusterer.prototype.resetViewport = function(opt_hide) {\n\t// Remove all the clusters\n\tfor (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n\t\tcluster.remove();\n\t}\n\n\t// Reset the markers to not be added and to be invisible.\n\tfor (var i = 0, marker; marker = this.markers_[i]; i++) {\n\t\tmarker.isAdded = false;\n\t\tif (opt_hide) {\n\t\t\tmarker.setMap(null);\n\t\t}\n\t}\n\n\tthis.clusters_ = [];\n};\n\n/**\n *\n */\nMarkerClusterer.prototype.repaint = function() {\n\tvar oldClusters = this.clusters_.slice();\n\tthis.clusters_.length = 0;\n\tthis.resetViewport();\n\tthis.redraw();\n\n\t// Remove the old clusters.\n\t// Do it in a timeout so the other clusters have been drawn first.\n\twindow.setTimeout(function() {\n\t\tfor (var i = 0, cluster; cluster = oldClusters[i]; i++) {\n\t\t\tcluster.remove();\n\t\t}\n\t}, 0);\n};\n\n\n/**\n * Redraws the clusters.\n */\nMarkerClusterer.prototype.redraw = function() {\n\tthis.createClusters_();\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @private\n */\nMarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {\n\tif (!p1 || !p2) {\n\t\treturn 0;\n\t}\n\n\tvar R = 6371; // Radius of the Earth in km\n\tvar dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n\tvar dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n\tvar a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n\t\tMath.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n\t\tMath.sin(dLon / 2) * Math.sin(dLon / 2);\n\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\tvar d = R * c;\n\treturn d;\n};\n\n\n/**\n * Add a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @private\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {\n\tvar distance = 40000; // Some large number\n\tvar clusterToAddTo = null;\n\tvar pos = marker.getPosition();\n\tfor (var i = 0, cluster; cluster = this.clusters_[i]; i++) {\n\t\tvar center = cluster.getCenter();\n\t\tif (center) {\n\t\t\tvar d = this.distanceBetweenPoints_(center, marker.getPosition());\n\t\t\tif (d < distance) {\n\t\t\t\tdistance = d;\n\t\t\t\tclusterToAddTo = cluster;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n\t\tclusterToAddTo.addMarker(marker);\n\t} else {\n\t\tvar cluster = new Cluster(this);\n\t\tcluster.addMarker(marker);\n\t\tthis.clusters_.push(cluster);\n\t}\n};\n\n\n/**\n * Creates the clusters.\n *\n * @private\n */\nMarkerClusterer.prototype.createClusters_ = function() {\n\tif (!this.ready_) {\n\t\treturn;\n\t}\n\n\t// Get our current map view bounds.\n\t// Create a new bounds object so we don't affect the map.\n\tvar mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),\n\t\tthis.map_.getBounds().getNorthEast());\n\tvar bounds = this.getExtendedBounds(mapBounds);\n\n\tfor (var i = 0, marker; marker = this.markers_[i]; i++) {\n\t\tif (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n\t\t\tthis.addToClosestCluster_(marker);\n\t\t}\n\t}\n};\n\n\n/**\n * A cluster that contains markers.\n *\n * @param {MarkerClusterer} markerClusterer The markerclusterer that this\n *     cluster is associated with.\n * @constructor\n * @ignore\n */\nfunction Cluster(markerClusterer) {\n\tthis.markerClusterer_ = markerClusterer;\n\tthis.map_ = markerClusterer.getMap();\n\tthis.gridSize_ = markerClusterer.getGridSize();\n\tthis.minClusterSize_ = markerClusterer.getMinClusterSize();\n\tthis.averageCenter_ = markerClusterer.isAverageCenter();\n\tthis.center_ = null;\n\tthis.markers_ = [];\n\tthis.bounds_ = null;\n\tthis.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),\n\t\tmarkerClusterer.getGridSize());\n}\n\n/**\n * Determins if a marker is already added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker is already added.\n */\nCluster.prototype.isMarkerAlreadyAdded = function(marker) {\n\tif (this.markers_.indexOf) {\n\t\treturn this.markers_.indexOf(marker) != -1;\n\t} else {\n\t\tfor (var i = 0, m; m = this.markers_[i]; i++) {\n\t\t\tif (m == marker) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\n\n/**\n * Add a marker the cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @return {boolean} True if the marker was added.\n */\nCluster.prototype.addMarker = function(marker) {\n\tif (this.isMarkerAlreadyAdded(marker)) {\n\t\treturn false;\n\t}\n\n\tif (!this.center_) {\n\t\tthis.center_ = marker.getPosition();\n\t\tthis.calculateBounds_();\n\t} else {\n\t\tif (this.averageCenter_) {\n\t\t\tvar l = this.markers_.length + 1;\n\t\t\tvar lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;\n\t\t\tvar lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;\n\t\t\tthis.center_ = new google.maps.LatLng(lat, lng);\n\t\t\tthis.calculateBounds_();\n\t\t}\n\t}\n\n\tmarker.isAdded = true;\n\tthis.markers_.push(marker);\n\n\tvar len = this.markers_.length;\n\tif (len < this.minClusterSize_ && marker.getMap() != this.map_) {\n\t\t// Min cluster size not reached so show the marker.\n\t\tmarker.setMap(this.map_);\n\t}\n\n\tif (len == this.minClusterSize_) {\n\t\t// Hide the markers that were showing.\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tthis.markers_[i].setMap(null);\n\t\t}\n\t}\n\n\tif (len >= this.minClusterSize_) {\n\t\tmarker.setMap(null);\n\t}\n\n\tthis.updateIcon();\n\treturn true;\n};\n\n\n/**\n * Returns the marker clusterer that the cluster is associated with.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n */\nCluster.prototype.getMarkerClusterer = function() {\n\treturn this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n */\nCluster.prototype.getBounds = function() {\n\tvar bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n\tvar markers = this.getMarkers();\n\tfor (var i = 0, marker; marker = markers[i]; i++) {\n\t\tbounds.extend(marker.getPosition());\n\t}\n\treturn bounds;\n};\n\n\n/**\n * Removes the cluster\n */\nCluster.prototype.remove = function() {\n\tthis.clusterIcon_.remove();\n\tthis.markers_.length = 0;\n\tdelete this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {number} The cluster center.\n */\nCluster.prototype.getSize = function() {\n\treturn this.markers_.length;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {Array.<google.maps.Marker>} The cluster center.\n */\nCluster.prototype.getMarkers = function() {\n\treturn this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster.\n *\n * @return {google.maps.LatLng} The cluster center.\n */\nCluster.prototype.getCenter = function() {\n\treturn this.center_;\n};\n\n\n/**\n * Calculated the extended bounds of the cluster with the grid.\n *\n * @private\n */\nCluster.prototype.calculateBounds_ = function() {\n\tvar bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n\tthis.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Determines if a marker lies in the clusters bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n */\nCluster.prototype.isMarkerInClusterBounds = function(marker) {\n\treturn this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Returns the map that the cluster is associated with.\n *\n * @return {google.maps.Map} The map.\n */\nCluster.prototype.getMap = function() {\n\treturn this.map_;\n};\n\n\n/**\n * Updates the cluster icon\n */\nCluster.prototype.updateIcon = function() {\n\tvar zoom = this.map_.getZoom();\n\tvar mz = this.markerClusterer_.getMaxZoom();\n\n\tif (mz && zoom > mz) {\n\t\t// The zoom is greater than our max zoom so show all the markers in cluster.\n\t\tfor (var i = 0, marker; marker = this.markers_[i]; i++) {\n\t\t\tmarker.setMap(this.map_);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (this.markers_.length < this.minClusterSize_) {\n\t\t// Min cluster size not yet reached.\n\t\tthis.clusterIcon_.hide();\n\t\treturn;\n\t}\n\n\tvar numStyles = this.markerClusterer_.getStyles().length;\n\tvar sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n\tthis.clusterIcon_.setCenter(this.center_);\n\tthis.clusterIcon_.setSums(sums);\n\tthis.clusterIcon_.show();\n};\n\n\n/**\n * A cluster icon\n *\n * @param {Cluster} cluster The cluster to be associated with.\n * @param {Object} styles An object that has style properties:\n *     'url': (string) The image url.\n *     'height': (number) The image height.\n *     'width': (number) The image width.\n *     'anchor': (Array) The anchor position of the label text.\n *     'textColor': (string) The text color.\n *     'textSize': (number) The text size.\n *     'backgroundPosition: (string) The background postition x, y.\n * @param {number=} opt_padding Optional padding to apply to the cluster icon.\n * @constructor\n * @extends google.maps.OverlayView\n * @ignore\n */\nfunction ClusterIcon(cluster, styles, opt_padding) {\n\tcluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n\tthis.styles_ = styles;\n\tthis.padding_ = opt_padding || 0;\n\tthis.cluster_ = cluster;\n\tthis.center_ = null;\n\tthis.map_ = cluster.getMap();\n\tthis.div_ = null;\n\tthis.sums_ = null;\n\tthis.visible_ = false;\n\n\tthis.setMap(this.map_);\n}\n\n\n/**\n * Triggers the clusterclick event and zoom's if the option is set.\n *\n * @param {google.maps.MouseEvent} event The event to propagate\n */\nClusterIcon.prototype.triggerClusterClick = function(event) {\n\tvar markerClusterer = this.cluster_.getMarkerClusterer();\n\n\t// Trigger the clusterclick event.\n\tgoogle.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_, event);\n\n\tif (markerClusterer.isZoomOnClick()) {\n\t\t// Zoom into the cluster.\n\t\tthis.map_.fitBounds(this.cluster_.getBounds());\n\t}\n};\n\n\n/**\n * Adding the cluster icon to the dom.\n * @ignore\n */\nClusterIcon.prototype.onAdd = function() {\n\tthis.div_ = document.createElement('DIV');\n\tif (this.visible_) {\n\t\tvar pos = this.getPosFromLatLng_(this.center_);\n\t\tthis.div_.style.cssText = this.createCss(pos);\n\t\tthis.div_.innerHTML = this.sums_.text;\n\t}\n\n\tvar panes = this.getPanes();\n\tpanes.overlayMouseTarget.appendChild(this.div_);\n\n\tvar that = this;\n\tvar isDragging = false;\n\tgoogle.maps.event.addDomListener(this.div_, 'click', function(event) {\n\t\t// Only perform click when not preceded by a drag\n\t\tif (!isDragging) {\n\t\t\tthat.triggerClusterClick(event);\n\t\t}\n\t});\n\tgoogle.maps.event.addDomListener(this.div_, 'mousedown', function() {\n\t\tisDragging = false;\n\t});\n\tgoogle.maps.event.addDomListener(this.div_, 'mousemove', function() {\n\t\tisDragging = true;\n\t});\n};\n\n\n/**\n * Returns the position to place the div dending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n * @private\n */\nClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {\n\tvar pos = this.getProjection().fromLatLngToDivPixel(latlng);\n\n\tif (typeof this.iconAnchor_ === 'object' && this.iconAnchor_.length === 2) {\n\t\tpos.x -= this.iconAnchor_[0];\n\t\tpos.y -= this.iconAnchor_[1];\n\t} else {\n\t\tpos.x -= parseInt(this.width_ / 2, 10);\n\t\tpos.y -= parseInt(this.height_ / 2, 10);\n\t}\n\treturn pos;\n};\n\n\n/**\n * Draw the icon.\n * @ignore\n */\nClusterIcon.prototype.draw = function() {\n\tif (this.visible_) {\n\t\tvar pos = this.getPosFromLatLng_(this.center_);\n\t\tthis.div_.style.top = pos.y + 'px';\n\t\tthis.div_.style.left = pos.x + 'px';\n\t}\n};\n\n\n/**\n * Hide the icon.\n */\nClusterIcon.prototype.hide = function() {\n\tif (this.div_) {\n\t\tthis.div_.style.display = 'none';\n\t}\n\tthis.visible_ = false;\n};\n\n\n/**\n * Position and show the icon.\n */\nClusterIcon.prototype.show = function() {\n\tif (this.div_) {\n\t\tvar pos = this.getPosFromLatLng_(this.center_);\n\t\tthis.div_.style.cssText = this.createCss(pos);\n\t\tthis.div_.style.display = '';\n\t}\n\tthis.visible_ = true;\n};\n\n\n/**\n * Remove the icon from the map\n */\nClusterIcon.prototype.remove = function() {\n\tthis.setMap(null);\n};\n\n\n/**\n * Implementation of the onRemove interface.\n * @ignore\n */\nClusterIcon.prototype.onRemove = function() {\n\tif (this.div_ && this.div_.parentNode) {\n\t\tthis.hide();\n\t\tthis.div_.parentNode.removeChild(this.div_);\n\t\tthis.div_ = null;\n\t}\n};\n\n\n/**\n * Set the sums of the icon.\n *\n * @param {Object} sums The sums containing:\n *   'text': (string) The text to display in the icon.\n *   'index': (number) The style index of the icon.\n */\nClusterIcon.prototype.setSums = function(sums) {\n\tthis.sums_ = sums;\n\tthis.text_ = sums.text;\n\tthis.index_ = sums.index;\n\tif (this.div_) {\n\t\tthis.div_.innerHTML = sums.text;\n\t}\n\n\tthis.useStyle();\n};\n\n\n/**\n * Sets the icon to the the styles.\n */\nClusterIcon.prototype.useStyle = function() {\n\tvar index = Math.max(0, this.sums_.index - 1);\n\tindex = Math.min(this.styles_.length - 1, index);\n\tvar style = this.styles_[index];\n\tthis.url_ = style['url'];\n\tthis.height_ = style['height'];\n\tthis.width_ = style['width'];\n\tthis.textColor_ = style['textColor'];\n\tthis.anchor_ = style['anchor'];\n\tthis.textSize_ = style['textSize'];\n\tthis.backgroundPosition_ = style['backgroundPosition'];\n\tthis.iconAnchor_ = style['iconAnchor'];\n};\n\n\n/**\n * Sets the center of the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function(center) {\n\tthis.center_ = center;\n};\n\n\n/**\n * Create the css text based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position.\n * @return {string} The css style text.\n */\nClusterIcon.prototype.createCss = function(pos) {\n\tvar style = [];\n\tstyle.push('background-image:url(' + this.url_ + ');');\n\tvar backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';\n\tstyle.push('background-position:' + backgroundPosition + ';');\n\n\tif (typeof this.anchor_ === 'object') {\n\t\tif (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&\n\t\t\tthis.anchor_[0] < this.height_) {\n\t\t\tstyle.push('height:' + (this.height_ - this.anchor_[0]) +\n\t\t\t\t'px; padding-top:' + this.anchor_[0] + 'px;');\n\t\t} else if (typeof this.anchor_[0] === 'number' && this.anchor_[0] < 0 &&\n\t\t\t-this.anchor_[0] < this.height_) {\n\t\t\tstyle.push('height:' + this.height_ + 'px; line-height:' + (this.height_ + this.anchor_[0]) +\n\t\t\t\t'px;');\n\t\t} else {\n\t\t\tstyle.push('height:' + this.height_ + 'px; line-height:' + this.height_ +\n\t\t\t\t'px;');\n\t\t}\n\t\tif (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&\n\t\t\tthis.anchor_[1] < this.width_) {\n\t\t\tstyle.push('width:' + (this.width_ - this.anchor_[1]) +\n\t\t\t\t'px; padding-left:' + this.anchor_[1] + 'px;');\n\t\t} else {\n\t\t\tstyle.push('width:' + this.width_ + 'px; text-align:center;');\n\t\t}\n\t} else {\n\t\tstyle.push('height:' + this.height_ + 'px; line-height:' +\n\t\t\tthis.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');\n\t}\n\n\tvar txtColor = this.textColor_ ? this.textColor_ : 'black';\n\tvar txtSize = this.textSize_ ? this.textSize_ : 11;\n\n\tstyle.push('cursor:pointer; top:' + pos.y + 'px; left:' +\n\t\tpos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +\n\t\ttxtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');\n\treturn style.join('');\n};\n\n\n// Export Symbols for Closure\n// If you are not going to compile with closure then you can remove the\n// code below.\nwindow['MarkerClusterer'] = MarkerClusterer;\nMarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;\nMarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;\nMarkerClusterer.prototype['clearMarkers'] =\n\tMarkerClusterer.prototype.clearMarkers;\nMarkerClusterer.prototype['fitMapToMarkers'] =\n\tMarkerClusterer.prototype.fitMapToMarkers;\nMarkerClusterer.prototype['getCalculator'] =\n\tMarkerClusterer.prototype.getCalculator;\nMarkerClusterer.prototype['getGridSize'] =\n\tMarkerClusterer.prototype.getGridSize;\nMarkerClusterer.prototype['getExtendedBounds'] =\n\tMarkerClusterer.prototype.getExtendedBounds;\nMarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;\nMarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;\nMarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;\nMarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;\nMarkerClusterer.prototype['getTotalClusters'] =\n\tMarkerClusterer.prototype.getTotalClusters;\nMarkerClusterer.prototype['getTotalMarkers'] =\n\tMarkerClusterer.prototype.getTotalMarkers;\nMarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;\nMarkerClusterer.prototype['removeMarker'] =\n\tMarkerClusterer.prototype.removeMarker;\nMarkerClusterer.prototype['removeMarkers'] =\n\tMarkerClusterer.prototype.removeMarkers;\nMarkerClusterer.prototype['resetViewport'] =\n\tMarkerClusterer.prototype.resetViewport;\nMarkerClusterer.prototype['repaint'] =\n\tMarkerClusterer.prototype.repaint;\nMarkerClusterer.prototype['setCalculator'] =\n\tMarkerClusterer.prototype.setCalculator;\nMarkerClusterer.prototype['setGridSize'] =\n\tMarkerClusterer.prototype.setGridSize;\nMarkerClusterer.prototype['setMaxZoom'] =\n\tMarkerClusterer.prototype.setMaxZoom;\nMarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;\nMarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;\n\nCluster.prototype['getCenter'] = Cluster.prototype.getCenter;\nCluster.prototype['getSize'] = Cluster.prototype.getSize;\nCluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;\n\nClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;\nClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;\nClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;"]}